#! /usr/bin/env ruby

require 'optparse'

NO_GUI=%w{off no}
GUI_MODES=%w{vizkit gzclient}

gui = 'vizkit'
gzserver_args = Array.new
start = false
options = OptionParser.new do |opt|
    opt.banner = "rock-gazebo SCENE"
    opt.on '--start', 'controls in vizkit3d visualization mode if rock-gazebo should configure and start the ModelTask components to ensure the visualization gets updated' do
        start = true
    end
    opt.on '--gui=MODE', String, "controls the GUI that is used.", "'vizkit' (the default) uses Vizkit3D,", "'gzclient' uses Gazebo\'s visualization and", "'no' disables visualization altogether" do |gui_mode|
        if NO_GUI.include?(gui_mode)
            gui = false
        elsif GUI_MODES.include?(gui_mode)
            gui = gui_mode
        else
            STDERR.puts "'#{gui}' is not a valide GUI mode"
        end
    end
    opt.on '--verbose', 'run gzserver in verbose mode' do
        gzserver_args << '--verbose'
    end
end

args = options.parse(ARGV)
if args.size != 1
    STDERR.puts "Scene argument missing"
    puts options
    exit 1
end
scene = args.first

require 'rock/bundles'

# Workaround: default_loader calls Orocos.load unconditionally :(
Orocos.disable_sigchld_handler = true
Bundles.load

if gui == 'vizkit'
    require 'Qt'
    require 'vizkit'
    require 'rock/gazebo'
    require 'rock_gazebo/viz'
else
    require 'rock/gazebo'
end

SDF::XML.model_path = Rock::Gazebo.model_path

subprocesses = Hash.new
begin
    gazebo_pid = Rock::Gazebo.spawn('gzserver', scene, *gzserver_args)
    subprocesses[gazebo_pid] = 'gzserver'
    if gui == 'vizkit'
        RockGazebo.viz(scene, start: start)
        timer = Qt::Timer.new
        timer.connect(SIGNAL('timeout()')) do
            if terminated_pid = Process.waitpid(-1, Process::WNOHANG)
                puts "#{subprocesses[terminated_pid]} finished (#{terminated_pid})"
                $qApp.quit
            end
        end
        timer.start(2000)
        Vizkit.exec
    elsif gui == 'gzclient'
        gzclient_pid = Rock::Gazebo.spawn('gzclient')
        subprocesses[gzclient_pid] = 'gzclient'
        terminated_pid = Process.waitpid
        puts "#{subprocesses[terminated_pid]} finished (#{terminated_pid})"
    else
        STDERR.puts "Press CTRL+C to quit"
        sleep
    end
ensure
    pids = subprocesses.find_all do |pid, name|
        next if pid == terminated_pid
        begin
            Process.kill('TERM', pid)
            puts "Terminating #{name} (#{pid})"
            true
        rescue Errno::ESRCH, Errno::ECHILD
        end
    end
    pids.each do |pid, name|
        puts "Waiting for #{name} (#{pid}) to terminate"
        begin Process.waitpid(pid)
        rescue Errno::ESRCH, Errno::ECHILD
        end
    end
end

